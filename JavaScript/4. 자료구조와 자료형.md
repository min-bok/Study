# **원시값의 메서드**
- 자바스크립트는 원시값도 객체에서 처럼 메서드를 호출할 수 있음
- 'null’과 'undefined’를 제외한 원시값만 가능 
- 원시값은 객체와 달리 프로퍼티를 추가할 수 없음

## **원시값을 객체처럼 사용하기**
원시값이 메서드나 프로퍼티에 접근하려하면 원시 래퍼 객체(object wrapper)"를 만들어 메서드를 실행하고 새로운 원시값을 반환한다. 이후 객체는 파괴되고 원시값만 남는다.
```js
let str = "Hello";

alert(str.toUpperCase()); // HELLO
```
1. 원시값 str에 접근하면 임시적인 래퍼 객체가 생성됨
2. 메서드를 실행하고 새로운 문자열을 반환
3. 래퍼 객체는 삭제되고 원시값 str만 남음

# **숫자형**
## **toString(base)**
- num.toString(base) 메서드는 base진법으로 num을 표현한 후, 이를 문자형으로 변환해 반환함
- base는 2~36까지의 수이며, 기본값은 10임
- 123e6 = 123000000
- 1e-6 = 0.000001 // 1에서 왼쪽으로 6번 소수점이동
```js
let num = 25;

num.toString(2); // '11001'
25..toString(2); // '11001'
```

## **어림수 관련 내장 함수**
- **Math.floor** : 소수점 첫째 자리에서 내림
- **Math.ceil** : 소수점 첫째 자리에서 올림
- **Math.round** : 소수점 첫째 자리에서 반올림
- **Math.trunc** : 소수부를 무시 (IE는 지원하지않음)
```js
let num = 2.4;

Math.floor(num) // 2
Math.ceil(num) // 3
Math.round(num) // 2
Math.round(2.5) // 3
Math.trunc(num) // 2
```

### **만약 소수점 n번째 자리 수에 대한 연산을 하고싶다면?**
1. 곱하기와 나누기
```js
let num = 1.23456;
Math.floor(num * 1000) / 1000 // 1.234
```
2. toFixed(n)
```js
num.toFixed(2)
'1.23'
```
- toFixed는 Math.round와 유사하게 가장 가까운 값으로 올림 혹은 버림해줌
 - toFixed의 반환 값은 문자열임
 - 소수부의 길이가 인수보다 작으면 끝에 0이 추가됨(문자열 반환 시)
 - 단항 덧셈 연산자나 Number()를 사용하면 문자형을 숫자형으로 변환가능함
```js
12.36.toFixed(1) // '12.4'
12.31.toFixed(1) // '12.3'

12.31.toFixed(3) // '12.310'

+12.39.toFixed(5) // 12.39
Number(12.39.toFixed(5)) // 12.39
```

## **부정확한 계산**
1. 숫자가 너무 커지면 64비트 공간이 넘쳐서 Infinity로 처리됨
2. 정밀도 손실(loss of precision)
```js
let sum = 0.1 + 0.2;

console.log(sum) // 0.30000000000000004
console.log(sum.toFixed(2)) // '0.30'
console.log(+sum.toFixed(2)) // 0.3
```
3. 곱하기와 나누기
```js
(0.1 * 100 + 0.2 * 100)/100 // 0.3
```

## **isNaN과 isFinite**
NaN, Infinity, -Infinity는 숫자형에 속하지만 정상적인 숫자는 아니므로 정상적인 숫자와 구분하기위한 특별한 함수가 존재한다.

### **isNaN()
인수를 숫자로 변환한 다음 NaN이면 true를, NaN가 아니라면 false를 반환함
```js
console.log(isNaN(NaN)) // true
console.log(isNaN(3)) // false
console.log(isNaN("str")) // true

// NaN은 자기자신을 포함하여 그 어떤 값과도 같지 않으므로, 어떤 값이 NaN인지 알기위해서는 이 함수가 필요하다.
console.log(NaN == NaN); // false
```

### **isFinite()**
인수를 숫자로 변환하고 그 숫자가 NaN/Infinity/-Infinity가 아닌 일반 숫자인 경우 true를 반환함
```js
console.log(isFinite(15)); // true
console.log(isFinite("15")); // true
console.log(isFinite("str")); // false
console.log(isFinite(NaN)); // false
console.log(isFinite(Infinity)); // false
```
- isFinite는 문자열이 일반 숫자인지 검증하는 데 사용됨
- 빈 문자열이나 공백은 isFinite를 포함한 모든 숫자 관련 내장 함수에서 0으로 취급된다는 점에 유의할 것
```js
let num = +prompt("숫자를 입력하세요", "");

console.log(isFinite(num)); // num이 1일 때 => true
console.log(isFinite(num)); // num이 "df"일 때 => false
console.log(isFinite(num)); // num이 " "일 때 => true
```

### **Object.is**
1. NaN을 대상으로 비교할 때
```js
NaN == NaN // false
Object.is(NaN, NaN) // true
```
2. 0과 -0이 다르게 취급되어야할 때
```js
0 === -0 // true
Object.is(0, -0) // false
```

## **parseInt와 parseFloat**
- 불가능할 때까지 문자열에서 숫자를 읽고, 숫자를 읽는 도중 오류가 발생하면 이미 수집된 숫자를 반환함
- `parseInt`는 정수를 반환함
- `parseFloat`는 부동 소수점 숫자를 반환함
```js
console.log(parseInt("100px")); // 100
console.log(parseInt("a123")) // NaN
console.log(parseFloat("123.4ds")) // 123.4
```

## **기타 수학 함수**
- **Math.random()** : 0이상 1미만의 난수를 반환
```js
Math.random(); // 0.18065355749024237
Math.random() * 100; // 13.18594782293152
Math.floor(Math.random(); * 100) // 39
```
- **Math.max(a, b, c...)** : 인수 중 최댓값 반환
```js
Math.max(1, 3, 10) // 10
Math.max(1, 3, '10') // 10
```
- **Math.min(a, b, c...)** : 인수 중 최솟값 반환
```js
Math.min(1, 3, 10) // 1
```
- **Math.pow(n, power)** : n을 power번 거듭제곱한 값을 반환
```js
Math.pow(2, 3); // 8
Math.pow(2, '3'); // 8
```

# **문자열**
- 자바스크립트에선 UTF-16을 사용해 문자열을 인코딩함
## **부분 문자열**
### **str.indexOf(substr, [pos])**
- substr가 존재하지 않으면 -1을 반환함
- 대소문자를 구분함
```js
let str = 'Widget with id';

str.indexOf("id"); // 1
str.indexOf("id", 2); // 12 두번째 등장하는 id의 위치를 반환
str.indexOf("hi"); // -1
```

### **str.includes(substr, [pos])**
- substr이 존재하면 true, 그렇지않으면 false를 반환함
```js
alert( "Widget".includes("id") ); // true
alert( "Widget".includes("id", 3) ); // false, 세 번째 위치 이후엔 "id"가 없음
```

### **str.startsWith와 str.endsWith**
**str.startsWith** : 문자열이 특정 문자열로 시작하는지 여부 확인
**str.endsWith** : 문자열이 특정 문자열로 끝나는지 여부 확인
```js
alert( "Widget".startsWith("Wid") ); // true, "Widget"은 "Wid"로 시작함
alert( "Widget".endsWith("get") ); // true, "Widget"은 "get"으로 끝남
```
## **부분 문자열 추출하기**
### **str.slice(start [, end])**
- 문자열의 start부터 end 바로 앞 위치까지를 반환함
- end가 생략된 경우에는 start부터 문자열 끝까지를 반환함
- 음수 인자를 허용함
```js
let str = "stringify";

console.log(str.slice(0, 3)); // str
console.log(str.slice(3)); // ingify
console.log(str.slice(-4, -1)); // gif
```
### **str.substring(start [, end])**
- slice와 매우 유사하지만 start가 end보다 커도 괜찮다는 차이점 존재
-  음수 인자를 허용하지 않음, 음수는 0으로 처리됨
```js
let str = "stringify";

console.log(str.substring(2, 6)); // ring
console.log(str.substring(6, 2)); // ring
```
### **str.substr(start [, length])**
- start에서부터 시작해 length 개의 글자를 반환
- 음수인자를 허용함
```js
let str = "stringify";

console.log(str.substr(2, 4)); // ring
console.log(str.substr(-5, 2)); // ng
```
# **배열**
- 순서가 있는 요소를 저장할 때 사용하는 자료구조
- 배열 요소의 자료형에는 제약이 없음
- 배열은 객체형에 속하므로 객체처럼 동작함 ex)참조를 통한 복사

## **큐(queue)**
- 한쪽 끝에서 삽입 작업이, 다른 쪽 끝에서 삭제 작업이 양쪽으로 이루어짐
- 삭제연산만 수행되는 곳을 프론트(front), 삽입연산만 이루어지는 곳을 리어(rear)라고 함
- 선입선출(FIFO)
- 주요 연산 : push/shift

## **스택(stack)**
- 한쪽끝에서 요소를 더하거나 뺄 수 있음
- 후입선출(LIFO)
- 주요 연산 : push/pop

## **성능**
- push와 pop은 빠르고, shift와 unshift는 느람
- shift와 unshift는 배열에 요소가 많으면 요소가 이동하는 데 걸리는 시간이 길고 메모리 관련 연산도 많아짐
- push와 pop 메서드는 요소를 옮기지 않으므로 각 요소는 기존 인덱스를 그대로 유지하므로 실행 속도가 빠름

## **반복문**
- for문
- for of문 : 현재 요소의 값만 구할 수 있음
- for in문 : 객체에 최적화되어있으므로 배열에서 사용하지 말 것

## **‘length’ 프로퍼티**
- length 프로퍼티는 배열 내 요소의 개수가 아니라 가장 큰 인덱스에 1을 더한 값임
```js
// 이렇게 사용하지말것
let fruits = [];
fruits[123] = "사과";

console.log(fruits.length); // 124
```
- arr.length = 0;을 통해 배열을 비울 수 있음
```js
let arr = [1, 2, 3, 4, 5];

arr.length = 2; // 요소 2개만 남기고 자르기

console.log(arr); // [1, 2]

arr.length = 5; // 삭제된 요소들은 복구되지않음

console.log(arr[3]); // undefined
```

## **다차원 배열**
- 배열은 다른 배열의 요소가 될 수 있음
- 행렬을 저장하는 용도로 쓰임
```js
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

cosole.log(matrix[1][1]); // 5, 중심에 있는 요소
```

## **.toString()**
```js
let arr = [1, 2, 3];

arr // [1, 2, 3]
arr.toString() // '1,2,3'
```

### **인접한 요소의 총합이 최대인 arr의 부분배열찾기**
```js
function getMaxSubSum(arr) {
  let maxSum = 0;

  for (let i = 0; i < arr.length; i++) {
    let sumFixedStart = 0;
    for (let j = i; j < arr.length; j++) {
      sumFixedStart += arr[j];
      maxSum = Math.max(maxSum, sumFixedStart);
    }
  }

  return maxSum;
}

getMaxSubSum([-1, 2, 3, -9]); // 5
```
#### **maxSum = Math.max(maxSum, sumFixedStart); 해설**
```js
1) m = (0, -1) => 0 // m = 0
p = -1 + 2 = 1
2) m = (0, 1) => 1 // m = 1
p = 1 + 3 = 4
3) m = (1, 4) => 4 // m = 4
p = 4 - 9 = -5
4) m = (4, -5) // m = 4
```

# **배열과 메서드**
## **요소 추가·제거 메서드**
- splice
- slice
- concat

## **forEach로 반복작업 하기**
```js
["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
  alert(`${item} is at index ${index} in ${array}`);
});

// Bilbo is at index 0 in Bilbo,Gandalf,Nazgul
// Gandalf is at index 1 in Bilbo,Gandalf,Nazgul
// Nazgul is at index 2 in Bilbo,Gandalf,Nazgul
```

## **배열 탐색하기**
- arr.indexOf(item, from)
- arr.lastIndexOf(item, from)
- arr.includes(item, from)

## **find와 findIndex**
객체로 구성된 배열을 다룰 때
```js
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

users.find(item => item.id == 3) // {id: 3, name: 'Mary'}
users.findIndex(item => item.id == 3) // 2
```

## **filter**
조건에 맞는 요소 전체를 담은 배열을 반환
```js
users.filter(item => item.id < 3)

// {id: 1, name: 'John'}
// {id: 2, name: 'Pete'}
```

## **배열을 변형/재정렬하는 메서드**
### **map**
```js
let arr = ["Bilbo", "Gandalf", "Nazgul"]

arr.map(item => item.length); // [5, 7, 6]
```

### **sort**
sort는 사전식 정렬된다.
```js
let arr = [ 1, 2, 15, 3, 4, 23, 54 ];

arr.sort(); // [1, 15, 2, 23, 3, 4, 54]

// 오름차순 정렬
arr.sort((a, b) => a - b); // [1, 2, 3, 4, 15, 23, 54]

// 내림차순 정렬
arr.sort((a, b) => b - a); // [54, 23, 15, 4, 3, 2, 1]
```

### **reverse**
arr의 요소를 역순으로 정렬
```js
let arr = [1, 2, 15, 3, 4, 23, 54];

arr.reverse() // [54, 23, 4, 3, 15, 2, 1]
```

### **split**
- 문자열을 배열로 바꿔줌
```js
let names = 'Bilbo, Gandalf, Nazgul';

let arr = names.split(",");

console.log(arr); // ['Bilbo', ' Gandalf', ' Nazgul']
```
- split(s)의 s를 빈 문자열로 지정하면 문자열을 글자 각각으로 분리할 수 있음
```js
let str = "test";

let arr = str.split("");

console.log(arr); // ['t', 'e', 's', 't']
```

### **join**
- 배열 요소를 모두 합쳐서 하나의 문자열로 반환함
```js
let arr = ['Hi', 'Im', 'Hodu'];

arr.join(" "); // 'Hi Im Hodu'
arr.join("?"); // 'Hi?Im?Hodu'
```

## **reduce와 reduceRight**
- `reduceRight`는 `reduce`와 동일한 기능을 하나 배열의 오른쪽부터 연산을 시작한다는 차이점이 있음 
```js
let arr = [1, 2, 3, 4, 5];

arr.reduce((sum, current) => sum + current, 0); // 15

// 초기값 0을 사용하지 않으면 배열이 비어있을 경우 에러발생함
```
```js
// 계산 흐름

sum current
 0     1
 1     2
 3     3
 6     4
 10    15
 ```

 ## **Array.isArray로 배열 여부 알아내기**
 - 배열은 객체형에 속하므로 typeof로는 객체와 배열을 구분할 수 없음
 - `Array.isArray`는 배열이면 true, 배열이 아니면 false를 반환함
 ```js
let obj = {};
let arr = [];

Array.isArray(obj); // false
Array.isArray(arr); // true
```

- sort, reverse, splice는 기존 배열을 변형시킨다는 점에 주의

# **iterable 객체**
- for..of을 사용할 수 있는 객체
- 이터러블엔 메서드 Symbol.iterator가 반드시 구현되어 있어야함
- 이터레이터엔 객체 {done: Boolean, value: any}을 반환하는 메서드 next()가 반드시 구현되어 있어야함
- 메서드 Symbol.iterator는 for..of에 의해 자동으로 호출되는데, 개발자가 명시적으로 호출하는 것도 가능함
- 배열, 문자열은 이터러블임

## **이터러블과 유사 배열**
- 유사 배열(array-like)이란 인덱스와 length 프로퍼티가 있어서 배열처럼 보이는 객체
- 문자열은 이터러블 객체이면서 유사배열 객체임
```js
let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2
};

// 유사배열이지만 이터러블 객체는 아님
```

## **Array.from**
- 이터러블, 유사 배열을 배열로 만들어줌
```js
let user = {
    0 : "Hodu",
    1 : "Hi",
    length : 2
};

let arr = Array.from(user);

console.log(arr); // ['Hodu', 'Hi']
```