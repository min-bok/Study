# **원시값의 메서드**
- 자바스크립트는 원시값도 객체에서 처럼 메서드를 호출할 수 있음
- 'null’과 'undefined’를 제외한 원시값만 가능 
- 원시값은 객체와 달리 프로퍼티를 추가할 수 없음

## **원시값을 객체처럼 사용하기**
원시값이 메서드나 프로퍼티에 접근하려하면 원시 래퍼 객체(object wrapper)"를 만들어 메서드를 실행하고 새로운 원시값을 반환한다. 이후 객체는 파괴되고 원시값만 남는다.
```js
let str = "Hello";

alert(str.toUpperCase()); // HELLO
```
1. 원시값 str에 접근하면 임시적인 래퍼 객체가 생성됨
2. 메서드를 실행하고 새로운 문자열을 반환
3. 래퍼 객체는 삭제되고 원시값 str만 남음

# **숫자형**
## **toString(base)**
- num.toString(base) 메서드는 base진법으로 num을 표현한 후, 이를 문자형으로 변환해 반환함
- base는 2~36까지의 수이며, 기본값은 10임
- 123e6 = 123000000
- 1e-6 = 0.000001 // 1에서 왼쪽으로 6번 소수점이동
```js
let num = 25;

num.toString(2); // '11001'
25..toString(2); // '11001'
```

## **어림수 관련 내장 함수**
- **Math.floor** : 소수점 첫째 자리에서 내림
- **Math.ceil** : 소수점 첫째 자리에서 올림
- **Math.round** : 소수점 첫째 자리에서 반올림
- **Math.trunc** : 소수부를 무시 (IE는 지원하지않음)
```js
let num = 2.4;

Math.floor(num) // 2
Math.ceil(num) // 3
Math.round(num) // 2
Math.round(2.5) // 3
Math.trunc(num) // 2
```

### **만약 소수점 n번째 자리 수에 대한 연산을 하고싶다면?**
1. 곱하기와 나누기
```js
let num = 1.23456;
Math.floor(num * 1000) / 1000 // 1.234
```
2. toFixed(n)
```js
num.toFixed(2)
'1.23'
```
- toFixed는 Math.round와 유사하게 가장 가까운 값으로 올림 혹은 버림해줌
 - toFixed의 반환 값은 문자열임
 - 소수부의 길이가 인수보다 작으면 끝에 0이 추가됨(문자열 반환 시)
 - 단항 덧셈 연산자나 Number()를 사용하면 문자형을 숫자형으로 변환가능함
```js
12.36.toFixed(1) // '12.4'
12.31.toFixed(1) // '12.3'

12.31.toFixed(3) // '12.310'

+12.39.toFixed(5) // 12.39
Number(12.39.toFixed(5)) // 12.39
```

## **부정확한 계산**
1. 숫자가 너무 커지면 64비트 공간이 넘쳐서 Infinity로 처리됨
2. 정밀도 손실(loss of precision)
```js
let sum = 0.1 + 0.2;

console.log(sum) // 0.30000000000000004
console.log(sum.toFixed(2)) // '0.30'
console.log(+sum.toFixed(2)) // 0.3
```
3. 곱하기와 나누기
```js
(0.1 * 100 + 0.2 * 100)/100 // 0.3
```

## **isNaN과 isFinite**
NaN, Infinity, -Infinity는 숫자형에 속하지만 정상적인 숫자는 아니므로 정상적인 숫자와 구분하기위한 특별한 함수가 존재한다.

### **isNaN()
인수를 숫자로 변환한 다음 NaN이면 true를, NaN가 아니라면 false를 반환함
```js
console.log(isNaN(NaN)) // true
console.log(isNaN(3)) // false
console.log(isNaN("str")) // true

// NaN은 자기자신을 포함하여 그 어떤 값과도 같지 않으므로, 어떤 값이 NaN인지 알기위해서는 이 함수가 필요하다.
console.log(NaN == NaN); // false
```

### **isFinite()**
인수를 숫자로 변환하고 그 숫자가 NaN/Infinity/-Infinity가 아닌 일반 숫자인 경우 true를 반환함
```js
console.log(isFinite(15)); // true
console.log(isFinite("15")); // true
console.log(isFinite("str")); // false
console.log(isFinite(NaN)); // false
console.log(isFinite(Infinity)); // false
```
- isFinite는 문자열이 일반 숫자인지 검증하는 데 사용됨
- 빈 문자열이나 공백은 isFinite를 포함한 모든 숫자 관련 내장 함수에서 0으로 취급된다는 점에 유의할 것
```js
let num = +prompt("숫자를 입력하세요", "");

console.log(isFinite(num)); // num이 1일 때 => true
console.log(isFinite(num)); // num이 "df"일 때 => false
console.log(isFinite(num)); // num이 " "일 때 => true
```

### **Object.is**
1. NaN을 대상으로 비교할 때
```js
NaN == NaN // false
Object.is(NaN, NaN) // true
```
2. 0과 -0이 다르게 취급되어야할 때
```js
0 === -0 // true
Object.is(0, -0) // false
```

## **parseInt와 parseFloat**
- 불가능할 때까지 문자열에서 숫자를 읽고, 숫자를 읽는 도중 오류가 발생하면 이미 수집된 숫자를 반환함
- `parseInt`는 정수를 반환함
- `parseFloat`는 부동 소수점 숫자를 반환함
```js
console.log(parseInt("100px")); // 100
console.log(parseInt("a123")) // NaN
console.log(parseFloat("123.4ds")) // 123.4
```

## **기타 수학 함수**
- **Math.random()** : 0이상 1미만의 난수를 반환
```js
Math.random(); // 0.18065355749024237
Math.random() * 100; // 13.18594782293152
Math.floor(Math.random(); * 100) // 39
```
- **Math.max(a, b, c...)** : 인수 중 최댓값 반환
```js
Math.max(1, 3, 10) // 10
Math.max(1, 3, '10') // 10
```
- **Math.min(a, b, c...)** : 인수 중 최솟값 반환
```js
Math.min(1, 3, 10) // 1
```
- **Math.pow(n, power)** : n을 power번 거듭제곱한 값을 반환
```js
Math.pow(2, 3); // 8
Math.pow(2, '3'); // 8
```

# **문자열**
- 자바스크립트에선 UTF-16을 사용해 문자열을 인코딩함
## **부분 문자열**
### **str.indexOf(substr, [pos])**
- substr가 존재하지 않으면 -1을 반환함
- 대소문자를 구분함
```js
let str = 'Widget with id';

str.indexOf("id"); // 1
str.indexOf("id", 2); // 12 두번째 등장하는 id의 위치를 반환
str.indexOf("hi"); // -1
```

### **str.includes(substr, [pos])**
- substr이 존재하면 true, 그렇지않으면 false를 반환함
```js
alert( "Widget".includes("id") ); // true
alert( "Widget".includes("id", 3) ); // false, 세 번째 위치 이후엔 "id"가 없음
```

### **str.startsWith와 str.endsWith**
**str.startsWith** : 문자열이 특정 문자열로 시작하는지 여부 확인
**str.endsWith** : 문자열이 특정 문자열로 끝나는지 여부 확인
```js
alert( "Widget".startsWith("Wid") ); // true, "Widget"은 "Wid"로 시작함
alert( "Widget".endsWith("get") ); // true, "Widget"은 "get"으로 끝남
```
## **부분 문자열 추출하기**
### **str.slice(start [, end])**
- 문자열의 start부터 end 바로 앞 위치까지를 반환함
- end가 생략된 경우에는 start부터 문자열 끝까지를 반환함
- 음수 인자를 허용함
```js
let str = "stringify";

console.log(str.slice(0, 3)); // str
console.log(str.slice(3)); // ingify
console.log(str.slice(-4, -1)); // gif
```
### **str.substring(start [, end])**
- slice와 매우 유사하지만 start가 end보다 커도 괜찮다는 차이점 존재
-  음수 인자를 허용하지 않음, 음수는 0으로 처리됨
```js
let str = "stringify";

console.log(str.substring(2, 6)); // ring
console.log(str.substring(6, 2)); // ring
```
### **str.substr(start [, length])**
- start에서부터 시작해 length 개의 글자를 반환
- 음수인자를 허용함
```js
let str = "stringify";

console.log(str.substr(2, 4)); // ring
console.log(str.substr(-5, 2)); // ng
```
# **배열**
- 순서가 있는 요소를 저장할 때 사용하는 자료구조
- 배열 요소의 자료형에는 제약이 없음
- 배열은 객체형에 속하므로 객체처럼 동작함 ex)참조를 통한 복사

## **큐(queue)**
- 한쪽 끝에서 삽입 작업이, 다른 쪽 끝에서 삭제 작업이 양쪽으로 이루어짐
- 삭제연산만 수행되는 곳을 프론트(front), 삽입연산만 이루어지는 곳을 리어(rear)라고 함
- 선입선출(FIFO)
- 주요 연산 : push/shift

## **스택(stack)**
- 한쪽끝에서 요소를 더하거나 뺄 수 있음
- 후입선출(LIFO)
- 주요 연산 : push/pop

## **성능**
- push와 pop은 빠르고, shift와 unshift는 느람
- shift와 unshift는 배열에 요소가 많으면 요소가 이동하는 데 걸리는 시간이 길고 메모리 관련 연산도 많아짐
- push와 pop 메서드는 요소를 옮기지 않으므로 각 요소는 기존 인덱스를 그대로 유지하므로 실행 속도가 빠름

## **반복문**
- for문
- for of문 : 현재 요소의 값만 구할 수 있음
- for in문 : 객체에 최적화되어있으므로 배열에서 사용하지 말 것

## **‘length’ 프로퍼티**
- length 프로퍼티는 배열 내 요소의 개수가 아니라 가장 큰 인덱스에 1을 더한 값임
```js
// 이렇게 사용하지말것
let fruits = [];
fruits[123] = "사과";

console.log(fruits.length); // 124
```
- arr.length = 0;을 통해 배열을 비울 수 있음
```js
let arr = [1, 2, 3, 4, 5];

arr.length = 2; // 요소 2개만 남기고 자르기

console.log(arr); // [1, 2]

arr.length = 5; // 삭제된 요소들은 복구되지않음

console.log(arr[3]); // undefined
```

## **다차원 배열**
- 배열은 다른 배열의 요소가 될 수 있음
- 행렬을 저장하는 용도로 쓰임
```js
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

cosole.log(matrix[1][1]); // 5, 중심에 있는 요소
```

## **.toString()**
```js
let arr = [1, 2, 3];

arr // [1, 2, 3]
arr.toString() // '1,2,3'
```

### **인접한 요소의 총합이 최대인 arr의 부분배열찾기**
```js
function getMaxSubSum(arr) {
  let maxSum = 0;

  for (let i = 0; i < arr.length; i++) {
    let sumFixedStart = 0;
    for (let j = i; j < arr.length; j++) {
      sumFixedStart += arr[j];
      maxSum = Math.max(maxSum, sumFixedStart);
    }
  }

  return maxSum;
}

getMaxSubSum([-1, 2, 3, -9]); // 5
```
#### **maxSum = Math.max(maxSum, sumFixedStart); 해설**
```js
1) m = (0, -1) => 0 // m = 0
p = -1 + 2 = 1
2) m = (0, 1) => 1 // m = 1
p = 1 + 3 = 4
3) m = (1, 4) => 4 // m = 4
p = 4 - 9 = -5
4) m = (4, -5) // m = 4
```