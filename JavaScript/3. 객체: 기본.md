# **객체**
- 오직 하나의 데이터만 담을 수 있는 원시형과 달리 다양한 데이터, 복잡한 객체를 저장할 수 있는 자료형
- 중괄호`{}`이용하여 만들 수 있으며, 중괄호 안에는 키(key):값(value)로 구성된 프로퍼티(property)를 여러개 넣을 수 있음
- 키는 문자형 또는 심볼형(문자형이나 심볼형이 아닌 경우에는 문자형으로 자동 형 변환됨), 값에는 모든 자료형이 허용됨
## 객체 정렬 방식
- 정수 프로퍼티(integer property)는 자동으로 정렬됨</br>
  (정수로 취급되길 원하지 않는다면 앞에 `+`를 붙여줌 ex) "+49")
- 그 외의 프로퍼티는 작성된 순서대로 정렬됨
## 객체를 만드는 두 가지 방법
```js
let user = new Object(); // '객체 생성자' 문법
let user = {};  // '객체 리터럴' 문법, 주로 사용되는 방식
```

## **대괄호 표기법**
- 키가 유효한 변수 식별자가 아닌 경우에 사용함
```js
let user = {
    name : "Hodu",
    age : 8,
    "like birds" : true,
}

user.name // 'Hodu'
user.like birds // Uncaught SyntaxError: Unexpected identifier
user["like birds"] // true
```
- 모든 표현식의 평가 결과를 프로퍼티 키로 사용할 수 있음
```js
let user = {
    name : "Hodu",
    age : 8,
    "like birds" : true
}

let key = "name";

console.log(user.key) // undefined
console.log(user[key]) // Hodu
```

## **계산된 프로퍼티(computed property)**
- 문자열 또는 문자열로 타입 변환할 수 있는 값으로 평가되는 표현식을 사용해 프로퍼티 키르르 동작으로 생성
- 프로퍼티 키로 사용할 표현식을 대괄호`[ ]`묶음
```js
let greeting = "Hi!";
let i = 0;

let obj = {};

obj[greeting + `Num ${++i}`] = i;

console.log(obj) // {Hi!Num 1: 1}
```

## **단축 프로퍼티**
- 변수를 프로퍼티 값으로 사용하는 경우 변수 이름과 프로퍼티 키의 이름이 동일한 경우 프로퍼티키를 생략가능
- 프로퍼티 키는 변수 이름으로 자동생성됨
```js
let name = "Hodu";
let age = 8;

let user = {
    name, // name : name과 같음
    age // age : age
}

console.log(user) // {name: 'Hodu', age: 8}
```

## **프로퍼티 삭제하기 : delete**
```js
let user = {
    name: 'Hodu', 
    age: 8, 
    species: 'cat'
}

delete user.name

console.log(user); // {age: 8, species: 'cat'}

## **프로퍼티 존재 여부 확인하기 : in 연산자**
- 객체 내부에 프로퍼티가 존재하면 `true`를, 존재하지 않으면 `false`를 반환함
```js
let user = {
    name : "Hodu",
    age : 8,
};

console.log("name" in user); // true
console.log("school" in user) // false
```

## **for..in 반복문**
- 객체의 모든 키를 순회할 수 있음
```js
let user = {
    name : "Hodu",
    age : 8,
    species : "Cat",
};

for(key in user) {
    console.log(key)
}
// name, age, species


for(key in user) {
    console.log(user[key])
}
// Hodu, 8, Cat
```

## **참조에 의한 객체 복사**
원시값이 값 그대로 저장, 할당, 복사 되는 반면 
```js
let name = "Hodu"
let cat = "kong"

console.log(name) // 'Hodu'
console.log(cat) // 'kong'

cat = "minbok"

console.log(name) // 'Hodu'
console.log(cat) // 'minbok'
```

객체는 변수에 객체가 그대로 저장되는 것이 아니라, 객체가 저장되어있는 '메모리 주소'인 객체에 대한 '참조 값'이 저장됨
```js
let user = {
    name : "Hodu",
    age : 8
}

let cat = user;

cat.name = "kong"

console.log(cat) // {name: 'kong', age: 8}
console.log(user) // {name: 'kong', age: 8}
```

## **객체 복제하기**
### **얕은 복사**
객체의 모든 프로퍼티가 원시값인 경우
#### **1) 반복문 사용하기**
```js
let user = {
    name : "Hodu"
}
let clone = {}

for(key in user) {
    clone[key] = user[key]
}

console.log(clone) // {name: 'Hodu'}

clone.name = "minbok"

console.log(user) // {name: 'Hodu'}
console.log(clone) // {name: 'minbok'}
```
#### **2) Object.assign**
```js
let user = {name : "Hodu"}
let userAge = {age : 8}
let userName = {name : "Minbok"} 

Object.assign(user, userAge, userName)

console.log(user) // {name: 'Minbok', age: 8}
console.log(userAge) //{age: 8}
console.log(useruserNameAge) // {name: 'Minbok'}
```
```js
let clone = Object.assign({}, user);

console.log(clone) // {name: 'Minbok', age: 8}
console.log(user) // {name: 'Minbok', age: 8}
```
### **깊은 복사(중첩 객체 복사)**
객체의 프로퍼티가 또 다른 객체로 이루어져있을때, 즉 중첩객체일때
```js
let user = {
  name: "Hodu",
  sizes: {
    height: "72cm",
    width: "6kg"
  }
};

let clone = Object.assign({}, user) 

console.log(clone) // name: "Hodu" sizes: {height: '72cm', width: '6kg'}

user.sizes.width = "7kg"

console.log(user) // name: "Hodu" sizes: {height: '72cm', width: '7kg'}

console.log(clone) // name: "Hodu" sizes: {height: '72cm', width: '7kg'}
```
중첩 객체 처리를 위해 Structured cloning algorithm 또는 lodash의 _.cloneDeep(obj)메서드가 필요함

## **가비지 컬렉션**
- 자바스크립트 엔진이 메모리에서 도달 가능성이 없는 값을 찾아내 삭제하는 것
- 이는 자바스크립트 엔진이 자동으로 수행하므로 개발자가 억지로 실행하거나 막을 수 없음

> **도달 가능성(reachability)**</br>
>- 어떻게든 접근하거나 사용할 수 있는 값
>- 외부로 나가는 참조는 도달 가능한 상태에 영향을 주지 않으며</br>
외부에서 들어오는 참조만이 도달 가능한 상태에 영향을 줌

```js
let user = {
  name: "John"
};

user = null;
```
위 예제에서 John은 도달할 수 없는 상태가 되었다. 
따라서 가비지 컬렉터는 이제 John에 저장된 데이터를 삭제하고, John을 메모리에서 삭제한다.

> **도달할 수 없는 섬**</br>
> 객체들이 연결되어 섬 같은 구조를 만드는데,</br>
> 이 섬에 도달할 방법이 없는 경우 섬을 구성하는 객체 전부를 메모리에서 삭제

### 가비지 컬렉션 내부 알고리즘 (mark-and-sweep)
- 가비지 컬렉터가 루트(root) 정보를 수집하고 이를 mark(기억)함
- 루트가 참조하고 있는 모든 객체에 방문한 후 이를 mark
- mark된 모든 객체 및 그 객체들이 참조하는 객체를 mark
- 루트에서 도달 가능한 모든 객체를 방문할 때까지 위 과정을 반복
- mark 되지 않은 모든 객체를 메모리에서 삭제함

## **메서드와 this**
### **메서드 (method)**
객체에 할당된 함수를 메서드 (method)라고 함
아래 예시에서 user에 할당된 sayHi는 메서드

```js
let user = {
    name : "Hodu",
    age : 8
}

user.sayHi = function() {
    alert("Hi!")
};

user.sayHi() // Hi!
```

### **this**
- this 값은 런타임에 결정됨
- 메서드가 어디서 정의되었는지에 상관없이 this는 ‘점 앞의’ 객체가 무엇인가에 따라 ‘자유롭게’ 결정됨
- this'는 '점(.) 앞의' 객체를 참조하기 때문에 동일한 함수라도 다른 객체에서 호출했다면 'this’가 참조하는 값이 달라짐
```js
// user.sayHi()가 실행되는 동안에 this는 user를 나타냄
let user = {
    name : "Hodu",
    age : 8,
    sayHi() {
        alert(`Hi ${this.name}!`)
    }
};

user.sayHi() // Hi Hodu!
```

```js
// 동일한 함수라도 다른 객체에서 호출했다면 'this’가 참조하는 값이 달라짐
let user = { name: "Hodu" };
let admin = { name: "Admin" };

function sayHi() {
  alert( this.name );
}

user.f = sayHi;
admin.f = sayHi;


user.f(); // Hodu
admin.f(); // Admin
```
## **new 연산자와 생성자 함수**
'new' 연산자와 생성자 함수를 사용하면 유사한 객체 여러 개를 쉽게 만들 수 있음

### **생성자 함수(constructor function)**
```js
function User(name) {
  // this = {};  (빈 객체가 암시적으로 만들어짐)

  // 새로운 프로퍼티를 this에 추가함
  this.name = name;
  this.isAdmin = false;

  // return this;  (this가 암시적으로 반환됨)
}
```
- 재사용할 수 있는 객체 생성 코드를 구현
- 함수 이름의 첫 글자는 대문자로 시작해야함
- 반드시 'new' 연산자를 붙여 실행해야함
- `new`와 함께 호출하면 내부에서 `this`가 암시적으로 만들어지고, 마지막엔 `this`가 반환됨
- 모든 함수는 생성자 함수가 될 수 있음(`new`를 붙여 실행하면 어떤 함수라도 생성자 함수 알고리즘이 실행됨)
``js
function User(name) {
    this.name = name;
    this.isAdmin = false;
}

let user = new User("민영");
let user2 = new User("호진");

console.log(user) // {name: '민영', isAdmin: false}
console.log(user2) // {name: '호진', isAdmin: false}
```
### **생성자 내 메서드**
```js
function User(name, age) {
    this.name = name;
    this.age = age;
    this.sayHi = function() {
        console.log(`안녕하세요 제 이름은 ${this.name}이고, 나이는 ${this.age}입니다!`);
    };
}

let hodu = new User('호두', '8살');
let minbok = new User('민복', '5살');

console.log(hodu.sayHi());
// 안녕하세요 제 이름은 호두이고, 나이는 8살입니다!
console.log(minbok.sayHi());
// 안녕하세요 제 이름은 민복이고, 나이는 5살입니다!
```

## 옵셔널 체이닝(optional chaining) '?.' 
- 옵셔널 체이닝을 사용하면 프로퍼티가 없는 **중첩 객체에 에러없이 안전하게 접근할 수 있음**
- `?.`'앞’의 평가 대상이 undefined나 null이면 평가를 멈추고 undefined를 반환함
- 왼쪽 평가대상이 없어도 괜찮은 경우에만 선택적으로 사용해야함
```js
let user = {}
let user2 = {
    address : {
        street : "undonggil"
    }        
}

console.log(user.address.street) // Uncaught TypeError: Cannot read properties of undefined (reading 'street')
console.log(user2.address.street) // undonggil

console.log(user?.address?.street) // undefined
console.log(user2?.address?.street) // undonggil
```
### **옵셔널 체이닝 문법을 사용하는 세 가지 형태**
1) obj?.prop – obj가 존재하면 obj.prop을 반환하고, 그렇지 않으면 undefined를 반환함
2) obj?.[prop] – obj가 존재하면 obj[prop]을 반환하고, 그렇지 않으면 undefined를 반환함
3) obj?.method() – obj가 존재하면 obj.method()를 호출하고, 그렇지 않으면 undefined를 반환함
### **존재 여부가 확실하지않은 함수 호출하기**
```js
let user1 = {
  admin() {
    alert("관리자 계정입니다.");
  }
}

let user2 = {};

// user1에 admin이 존재하면 메서드를 호출함
user1.admin?.(); // 관리자 계정입니다.
// user2에 admin이 존재하지 않아도 에러를 내보내지 않고 평가가 정지됨
user2.admin?.();
```
### 옵셔널 체이닝을 이용한 삭제
```js
let user = {
    name : "Hodu",
    age : 8
}

console.log(user) // name: 'Hodu', age: 8}

delete user?.age // user가 존재하면 user.age을 삭제

console.log(user) // {name: 'Hodu'}
``