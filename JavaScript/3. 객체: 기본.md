# **객체**
- 오직 하나의 데이터만 담을 수 있는 원시형과 달리 다양한 데이터, 복잡한 객체를 저장할 수 있는 자료형
- 중괄호`{}`이용하여 만들 수 있으며, 중괄호 안에는 키(key):값(value)로 구성된 프로퍼티(property)를 여러개 넣을 수 있음
- 키는 문자형 또는 심볼형(문자형이나 심볼형이 아닌 경우에는 문자형으로 자동 형 변환됨), 값에는 모든 자료형이 허용됨
## 객체 정렬 방식
- 정수 프로퍼티(integer property)는 자동으로 정렬됨</br>
  (정수로 취급되길 원하지 않는다면 앞에 `+`를 붙여줌 ex) "+49")
- 그 외의 프로퍼티는 작성된 순서대로 정렬됨
## 객체를 만드는 두 가지 방법
```js
let user = new Object(); // '객체 생성자' 문법
let user = {};  // '객체 리터럴' 문법, 주로 사용되는 방식
```

## **대괄호 표기법**
- 키가 유효한 변수 식별자가 아닌 경우에 사용함
```js
let user = {
    name : "Hodu",
    age : 8,
    "like birds" : true,
}

user.name // 'Hodu'
user.like birds // Uncaught SyntaxError: Unexpected identifier
user["like birds"] // true
```
- 모든 표현식의 평가 결과를 프로퍼티 키로 사용할 수 있음
```js
let user = {
    name : "Hodu",
    age : 8,
    "like birds" : true
}

let key = "name";

console.log(user.key) // undefined
console.log(user[key]) // Hodu
```

## **계산된 프로퍼티(computed property)**
- 문자열 또는 문자열로 타입 변환할 수 있는 값으로 평가되는 표현식을 사용해 프로퍼티 키르르 동작으로 생성
- 프로퍼티 키로 사용할 표현식을 대괄호`[ ]`묶음
```js
let greeting = "Hi!";
let i = 0;

let obj = {};

obj[greeting + `Num ${++i}`] = i;

console.log(obj) // {Hi!Num 1: 1}
```

## **단축 프로퍼티**
- 변수를 프로퍼티 값으로 사용하는 경우 변수 이름과 프로퍼티 키의 이름이 동일한 경우 프로퍼티키를 생략가능
- 프로퍼티 키는 변수 이름으로 자동생성됨
```js
let name = "Hodu";
let age = 8;

let user = {
    name, // name : name과 같음
    age // age : age
}

console.log(user) // {name: 'Hodu', age: 8}
```

## **프로퍼티 삭제하기 : delete**
```js
let user = {
    name: 'Hodu', 
    age: 8, 
    species: 'cat'
}

delete user.name

console.log(user); // {age: 8, species: 'cat'}

## **프로퍼티 존재 여부 확인하기 : in 연산자**
- 객체 내부에 프로퍼티가 존재하면 `true`를, 존재하지 않으면 `false`를 반환함
```js
let user = {
    name : "Hodu",
    age : 8,
};

console.log("name" in user); // true
console.log("school" in user) // false
```

## **for..in 반복문**
- 객체의 모든 키를 순회할 수 있음
```js
let user = {
    name : "Hodu",
    age : 8,
    species : "Cat",
};

for(key in user) {
    console.log(key)
}
// name, age, species


for(key in user) {
    console.log(user[key])
}
// Hodu, 8, Cat
```

## **참조에 의한 객체 복사**
원시값이 값 그대로 저장, 할당, 복사 되는 반면 
```js
let name = "Hodu"
let cat = "kong"

console.log(name) // 'Hodu'
console.log(cat) // 'kong'

cat = "minbok"

console.log(name) // 'Hodu'
console.log(cat) // 'minbok'
```

객체는 변수에 객체가 그대로 저장되는 것이 아니라, 객체가 저장되어있는 '메모리 주소'인 객체에 대한 '참조 값'이 저장됨
```js
let user = {
    name : "Hodu",
    age : 8
}

let cat = user;

cat.name = "kong"

console.log(cat) // {name: 'kong', age: 8}
console.log(user) // {name: 'kong', age: 8}
```

## **객체 복제하기**
### **얕은 복사**
객체의 모든 프로퍼티가 원시값인 경우
#### **1) 반복문 사용하기**
```js
let user = {
    name : "Hodu"
}
let clone = {}

for(key in user) {
    clone[key] = user[key]
}

console.log(clone) // {name: 'Hodu'}

clone.name = "minbok"

console.log(user) // {name: 'Hodu'}
console.log(clone) // {name: 'minbok'}
```
#### **2) Object.assign**
```js
let user = {name : "Hodu"}
let userAge = {age : 8}
let userName = {name : "Minbok"} 

Object.assign(user, userAge, userName)

console.log(user) // {name: 'Minbok', age: 8}
console.log(userAge) //{age: 8}
console.log(useruserNameAge) // {name: 'Minbok'}
```
```js
let clone = Object.assign({}, user);

console.log(clone) // {name: 'Minbok', age: 8}
console.log(user) // {name: 'Minbok', age: 8}
```
### **깊은 복사(중첩 객체 복사)**
객체의 프로퍼티가 또 다른 객체로 이루어져있을때, 즉 중첩객체일때
```js
let user = {
  name: "Hodu",
  sizes: {
    height: "72cm",
    width: "6kg"
  }
};

let clone = Object.assign({}, user) 

console.log(clone) // name: "Hodu" sizes: {height: '72cm', width: '6kg'}

user.sizes.width = "7kg"

console.log(user) // name: "Hodu" sizes: {height: '72cm', width: '7kg'}

console.log(clone) // name: "Hodu" sizes: {height: '72cm', width: '7kg'}
```
중첩 객체 처리를 위해 Structured cloning algorithm 또는 lodash의 _.cloneDeep(obj)메서드가 필요함