# **null**
- 존재하지 않는(nothing) 값, 비어 있는(empty) 값,</br> 알 수 없는(unknown) 값을 의미함

- 숫자형으로 변환 시 0으로 변환됨
# **undefined**
- 값이 할당되지 않은 상태를 의미함.</br>
- 변수는 선언했지만, 값을 할당하지 않았다면</br>
해당 변수에 undefined가 자동으로 할당됨</br>
(즉, **값이 할당되지 않은 변수의 초기값**을 의미함)

- 숫자형으로 변환 시 NaN으로 변환됨

# **불린형으로 형변환: Boolean()**
* 0, null, undefined, NaN, ""	=> false
* 그 외의 값 => true
* 문자열 "0"과 " "같은 공백 => true

# **증가·감소 연산자**
- 증가(increment) 연산자 **++는 변수를 1 증가** 시킴</br>
- 감소(decrement) 연산자 -**-는 변수를 1 감소** 시킴

### **후위형(postfix form) : counter++**
값을 증가시키지만, 증가 전의 기존값을 사용하려할 때
```js
let five = 5;

five++ // 5
five // 6
```
### **전위형(prefix form) : ++counter**
값을 증가시키고 난 후, 증가한 값을 바로 사용하려할 때
```js
let five = 5;

++five // 6
five // 6
```

# **동등 연산자(equality operator) : ==**

- 피연산자를 숫자형으로 바꾼 후 비교함
- undefined나 null일 때 형 변환을 하지않음
- undefined와 null을 비교하는 경우, true를 반환
- null이나 undefined를 다른 값과 비교할 때는</br>
  무조건 false를 반환

 ```js
// 동등 연산자의 문제점

 alert( 0 == false ); // true
 ```
# **일치 연산자(strict equality operator) : ===**
- 형 변환 없이 값을 비교할 수 있음
- 자료형의 동등 여부까지 검사

# **논리 연산자**
## **|| (OR)**
- 인수 중 하나라도 true이면 true를 반환하고, 그렇지 않으면 false를 반환
- 피연산자가 불린형이 아니면, 평가를 위해 불린형으로 변환
- OR "||" 연산자를 여러 개 체이닝(chaining) 하면 첫 번째 falsy를 반환,</br> 
피연산자에 truthy가 하나도 없다면 마지막 피연산자를 반환

## **&& (AND)**
- 두 피연산자가 모두가 참일 때 true를 반환,</br> 
 그 외의 경우는 false를 반환하죠.
- 피연산자가 불린형이 아니면, 평가를 위해 불린형으로 변환
- AND 연산자는 첫 번째 falsy를 반환</br> 
 피연산자에 falsy가 없다면 마지막 값을 반환

 ## **! (NOT)**
- 피연산자를 불린형(true / false)으로 변환합니다.
- 1에서 변환된 값의 역을 반환합니다.

> **논리연산자의 우선순위**</br> 
NOT 연산자 > AND 연산자 (&&) > OR 연산자 (||)

# **nullish 병합 연산자 '??'**
스펙에 추가된 지 얼마 안 된 문법입니다. 구식 브라우저는 폴리필이 필요합니다.
> **폴리필 (polyfill)**</br>
웹 개발에서 기능을 지원하지 않는 웹 브라우저 상의 </br>기능을 구현하는 코드
- 피연산자 중 ‘값이 할당된’ 변수를 빠르게 찾을 수 있음
- 변수에 기본값을 할당하는 용도로 사용할 수 있음
```js
// height가 null이나 undefined인 경우, 100을 할당

height = height ?? 100;
```
- 연산자 우선순위가 낮은 편이므로 복잡한 표현식 안에서</br>  사용할 때는 괄호를 추가하는 것이 좋음
- 안정성 관련 이슈 때문에 &&나 ||와 함께 사용할 수 없음
```js
let x = 1 && 2 ?? 3; 
// SyntaxError: Unexpected token '??'

// 괄호를 사용하면 제약을 피할 수 있음

let x = (1 && 2) ?? 3;

alert(x); // 2
```

# **break**
- 반복문의 조건이 falsy가 되지않아도 </br>
언제든 원하는때에 반복문을 종료할 수 있음
- break를 만나면 반복문이 즉시 중단되고</br>
 제어 흐름이 반복문 아래 첫 번째 줄로 이동함

# **continue**
- 전체 반복문을 멈추지 않음
- 현재 실행 중인 이터레이션을 멈추고 다음 이터레이션을</br> 강제로 실행시킴 (조건을 통과하는 경우)

# **break/continue와 레이블**
여러 개의 중첩 반복문을 한 번에 빠져나와야 하는 경우에 사용
```js
outer: for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`(${i},${j})의 값`, '');

    /* 사용자가 아무것도 입력하지 않거나 
    Cancel 버튼을 누르는 경우 반복문을 빠져나옴*/
    if (!input) break outer;
  }
}
alert('완료!');
```

함수 부터 보기
https://ko.javascript.info/function-basics

# **콜백 함수**
함수를 다른 함수의 인수로 전달하고,</br>
필요하다면 인수로 전달한 그 함수를 "나중에 호출(called back)"하는 것

# **함수 표현식 vs 함수 선언문**
## **차이점**
### **1) 문법**
```js
// 함수 선언문
function sum(a, b) {
  return a + b;
}
```
```js
// 함수 표현식
let sum = function(a, b) {
  return a + b;
};
```

### **2) 자바스크립트 엔진이 함수를 생성하는 시점**
#### **함수 선언문**
- 자바스크립트는 스크립트 실행 전 초기화 단계에서 전역에 선언된 함수 선언문을 찾고 생성한다.</br>
따라서 전역으로 선언된 함수 선언문은 스크립트의 
위치에 상관없이 어디에서든 호출할 수 있다.</br>
- 함수 선언문은 함수 선언문이 정의되기 전에도 호출할 수 있습니다

#### **함수 표현식**
- 실제 실행 흐름이 해당 함수에 도달했을 때 함수를 생성하므로 실행 흐름이 함수에 도달했을 때부터 해당 함수를 사용할 수 있음

### **스코프**
#### **함수 선언문**
함수가 선언된 코드 블록 안에서만 유효
#### **함수 표현식**
코드 블록 외부에 선언한 변수에 함수 표현식으로 만든 함수를 할당하는 방법으로 코드 외부에서도 함수를 호출할 수 있음